#! /usr/bin/env python3

"""
rename_er_episodes.py
---------------------

This script copies downloaded Eisenbahn-Romantik video files (*.mp4) from a
source folder to a destination folder, naming the copied files based on
official episode information exported from TheTVDB.

It uses the JSON file generated by the scraper script
    eisenbahn_romantik_tvdb_with_specials.json
which must be located in the same directory as this script.

The script attempts to:
  â€¢ extract a human-readable title from each MP4 filename
  â€¢ find the best matching episode using fuzzy title matching
  â€¢ copy the file to destination_folder using this pattern:

        Eisenbahn-Romantik <season_episode_code> - <air_date_iso> - <abs_episode> - <title>.mp4

Usage:
    python copy_er_episodes.py <source_folder> <destination_folder>

Notes:
  â€¢ Non-matching or low-confidence matches (score < 0.50) are skipped.
  â€¢ No files are overwritten; existing target filenames are preserved.
"""

import os
import sys
import json
import glob
import re
import unicodedata
import shutil
from difflib import SequenceMatcher

JSON_FILE = "eisenbahn_romantik_tvdb_episodes_and_specials.json"


# ----------------------------------------------------------------------
# Normalization helpers
# ----------------------------------------------------------------------

def normalize(s):
    s = s.replace("\u00df", "ss")
    s = s.replace("_", " ")
    s = s.lower()
    s = unicodedata.normalize("NFKD", s)
    s = "".join(c for c in s if c.isalnum() or c.isspace())
    s = re.sub(r"\s+", " ", s).strip()
    return s


SERIES_PREFIX_RE = re.compile(
    r"""^\s*
        eisenbahn\s*[-â€“â€”]?\s*romantik
        \s*(?:[:\-â€“â€”]\s*)?
    """,
    re.IGNORECASE | re.VERBOSE,
)


def strip_series_prefix(s):
    if not s:
        return s
    return SERIES_PREFIX_RE.sub("", s).strip()


# ----------------------------------------------------------------------
# Episode loading
# ----------------------------------------------------------------------

def load_episodes(json_path):
    with open(json_path, "r", encoding="utf-8") as f:
        data = json.load(f)

    episodes = []
    for ep in data:
        title = ep.get("title", "")
        episodes.append(
            {
                "season_episode_code": ep.get("season_episode_code", ""),
                "air_date_iso": ep.get("air_date_iso", ""),
                "abs_episode": ep.get("abs_episode"),
                "title": title,
                # normalized full title (kept for reference/debugging)
                "norm_title": normalize(title),
                # normalized title WITHOUT "Eisenbahn-Romantik"
                "norm_title_noprefix": normalize(strip_series_prefix(title)),
            }
        )
    return episodes


# ----------------------------------------------------------------------
# Filename parsing
# ----------------------------------------------------------------------

def extract_raw_title_from_filename(filename):
    name = os.path.splitext(os.path.basename(filename))[0]
    name = re.sub(r"^Eisenbahn[- ]?Romantik[- ]*", "", name, flags=re.IGNORECASE)
    name = re.sub(r"[- ]\d{5,}$", "", name).strip()
    name = name.replace("_", " ")
    return name.strip()


# ----------------------------------------------------------------------
# Matching logic
# ----------------------------------------------------------------------

def contains_whole_query(query, candidate):
    return f" {query} " in f" {candidate} "

def find_best_match(title, episodes):
    norm_title = normalize(strip_series_prefix(title))
    if not norm_title:
        return None, 0.0

    best_ep = None
    best_score = 0.0

    for ep in episodes:
        cand = ep["norm_title_noprefix"]
        if not cand:
            continue

        # ðŸš¨ HARD RULE: exact containment wins
        if contains_whole_query(norm_title, cand):
            return ep, 1.0

        score = SequenceMatcher(None, norm_title, cand).ratio()

        if score > best_score:
            best_score = score
            best_ep = ep

    return best_ep, best_score


# ----------------------------------------------------------------------
# Filename construction
# ----------------------------------------------------------------------

def sanitize_for_filename(s):
    s = s.replace("/", "-").replace("\\", "-")
    s = re.sub(r'[:*?"<>|]', "", s)
    return s.strip()


def build_new_filename(ep):
    season_code = ep["season_episode_code"] or "S00E00"
    air_date = ep["air_date_iso"] or "0000-00-00"
    abs_ep = ep["abs_episode"]
    abs_ep_str = str(abs_ep) if abs_ep is not None else "0"
    title = sanitize_for_filename(ep["title"] or "Unknown Title")
    return f"Eisenbahn-Romantik {season_code} - {air_date} - {abs_ep_str} - {title}.mp4"


# ----------------------------------------------------------------------
# Main
# ----------------------------------------------------------------------

def main():
    if len(sys.argv) != 3:
        print("Usage: python copy_er_episodes.py <source_folder> <destination_folder>")
        sys.exit(1)

    source_folder = os.path.abspath(sys.argv[1])
    destination_folder = os.path.abspath(sys.argv[2])

    print(f"Source folder:      {source_folder}")
    print(f"Destination folder: {destination_folder}")

    if not os.path.isdir(source_folder):
        print(f"ERROR: source_folder does not exist or is not a directory: {source_folder}")
        sys.exit(1)

    os.makedirs(destination_folder, exist_ok=True)

    if not os.path.exists(JSON_FILE):
        print(f"ERROR: JSON file missing: {JSON_FILE}")
        sys.exit(1)

    episodes = load_episodes(JSON_FILE)

    mp4_files = glob.glob(os.path.join(source_folder, "*.mp4"))
    if not mp4_files:
        print("No .mp4 files found in source folder.")
        return

    print(f"Found {len(mp4_files)} .mp4 files")

    copied = 0
    skipped = 0

    for src_path in mp4_files:
        raw_title = extract_raw_title_from_filename(src_path)
        best_ep, score = find_best_match(raw_title, episodes)

        print(f"\nFile: {src_path}")
        print(f"  Extracted title: {raw_title}")

        if not best_ep:
            print("  No episode match found, skipping.")
            skipped += 1
            continue

        print(f"  Best match: {best_ep['title']} (score {score:.3f})")

        if score < 0.50:
            print("  Match score < 0.50 â€” skipping to avoid errors.")
            skipped += 1
            continue

        new_name = build_new_filename(best_ep)
        dst_path = os.path.join(destination_folder, new_name)

        if os.path.exists(dst_path):
            print(f"  Target already exists: {dst_path} â€” skipping.")
            skipped += 1
            continue

        print(f"  Copying to: {dst_path}")
        shutil.copy2(src_path, dst_path)
        copied += 1

    print(f"\nDone. Copied: {copied}, Skipped: {skipped}")


if __name__ == "__main__":
    main()
